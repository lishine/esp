/* Blink Example Modified for ADC Reading (Legacy Driver & Calibration)

   Reads ADC1 Channel 4 (GPIO 4) using legacy driver, applies legacy calibration,
   prints voltage, and blinks LED on GPIO 8 (4s ON, 1s OFF).
*/
#include <stdio.h>
#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "sdkconfig.h" // Generated by menuconfig

// ADC Includes (Legacy)
#include "driver/adc.h" // Use legacy driver header
#include "esp_adc_cal.h" // Use legacy calibration header

static const char *TAG = "ADC_BLINK_LEGACY";

// Define the GPIO pin number for LED directly
#define BLINK_GPIO 8

// ADC Configuration (Legacy)
#define ADC1_CHAN4 ADC1_CHANNEL_4 // GPIO4 is ADC1_CH4 on ESP32-C3
#define ADC_ATTEN ADC_ATTEN_DB_11 // Use 11dB attenuation for legacy driver (check datasheet for range)
#define ADC_WIDTH ADC_WIDTH_BIT_12 // Use 12-bit width

// ADC Calibration Data
static esp_adc_cal_characteristics_t adc1_chars; // Store legacy calibration characteristics
static bool adc_calibrated = false;

// Function to initialize Legacy ADC and Calibration
static void adc_init_legacy(void)
{
    //-------------ADC1 Config---------------//
    ESP_ERROR_CHECK(adc1_config_width(ADC_WIDTH_BIT_12)); // Use correct enum
    ESP_ERROR_CHECK(adc1_config_channel_atten(ADC1_CHAN4, ADC_ATTEN));

    //-------------ADC1 Legacy Calibration Init---------------//
    esp_err_t cali_ret = esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_TP);
    if (cali_ret == ESP_ERR_NOT_SUPPORTED) {
        ESP_LOGW(TAG, "Calibration scheme not supported or eFuse values not available for Two Point Calibration");
        // Optionally check for other schemes like Vref
        cali_ret = esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_VREF);
         if (cali_ret == ESP_OK) {
             ESP_LOGI(TAG, "Using eFuse Vref for calibration");
             esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN, ADC_WIDTH_BIT_12, 0, &adc1_chars); // Use correct enum
             adc_calibrated = true;
         } else {
             ESP_LOGE(TAG, "No suitable eFuse calibration values found.");
             adc_calibrated = false;
         }
    } else if (cali_ret == ESP_ERR_INVALID_VERSION) {
        ESP_LOGW(TAG, "Calibration version mismatch for Two Point Calibration");
        adc_calibrated = false;
    } else if (cali_ret == ESP_OK) {
        ESP_LOGI(TAG, "Using Two Point Calibration");
        esp_adc_cal_characterize(ADC_UNIT_1, ADC_ATTEN, ADC_WIDTH_BIT_12, 0, &adc1_chars); // Use correct enum
        adc_calibrated = true;
    } else {
         ESP_LOGE(TAG, "eFuse check failed with error: %s", esp_err_to_name(cali_ret));
         adc_calibrated = false;
    }

    if (adc_calibrated) {
         ESP_LOGI(TAG, "ADC1 calibration successful.");
    } else {
         ESP_LOGW(TAG, "ADC1 calibration failed or not performed.");
    }
}


static void configure_led(void)
{
    ESP_LOGI(TAG, "Configuring GPIO%d as output", BLINK_GPIO);
    gpio_reset_pin(BLINK_GPIO);
    /* Set the GPIO as a push/pull output */
    gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);
}

void app_main(void)
{
    /* Configure the LED peripheral */
    configure_led();

    /* Configure the ADC peripheral using legacy functions */
    adc_init_legacy();

    int adc_raw;
    uint32_t voltage_mv; // Voltage in millivolts (using legacy API return type)

    while (1) {
        // --- ADC Reading (Legacy) ---
        adc_raw = adc1_get_raw(ADC1_CHAN4);
        if (adc_raw == -1) {
             ESP_LOGE(TAG, "ADC read failed (invalid channel?)");
        } else {
            // ESP_LOGI(TAG, "Raw ADC Data: %d", adc_raw); // Uncomment for raw value debugging
            if (adc_calibrated) {
                voltage_mv = esp_adc_cal_raw_to_voltage(adc_raw, &adc1_chars);
                // Print voltage in Volts (Corrected GPIO number)
                ESP_LOGI(TAG, "GPIO%d Voltage: %.3f V", 4, (float)voltage_mv / 1000.0); // Use literal 4 for GPIO4
            } else {
                ESP_LOGW(TAG, "ADC Not Calibrated. Raw value: %d", adc_raw);
            }
        }

        // --- LED Blinking (4s ON, 1s OFF) ---
        ESP_LOGD(TAG, "Turning LED ON"); // Use Debug level for less verbose blink logs
        gpio_set_level(BLINK_GPIO, 1);
        vTaskDelay(4000 / portTICK_PERIOD_MS);

        ESP_LOGD(TAG, "Turning LED OFF");
        gpio_set_level(BLINK_GPIO, 0);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
}