/* Blink Example Modified for ADC Reading (Modern API)

   Reads ADC1 Channel 4 (GPIO 4) using one-shot driver every 500ms, applies
   curve-fitting calibration (if available), prints voltage, and blinks LED
   on GPIO 8 (0.2s ON, 5s OFF).
*/
#include <stdio.h>
#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "sdkconfig.h" // Generated by menuconfig
#include "esp_timer.h" // For esp_timer_get_time

// Modern ADC Includes
#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"

static const char *TAG = "ADC_BLINK_NG"; // NG for Next Gen

// Define the GPIO pin number for LED directly
#define BLINK_GPIO 8

// ADC Configuration
#define ADC1_CHAN4 ADC_CHANNEL_4 // GPIO4 is ADC1_CH4 on ESP32-C3
#define ADC_ATTEN ADC_ATTEN_DB_12 // Use 12dB attenuation for modern driver

// LED Timing Configuration (milliseconds)
#define LED_ON_DURATION_MS 200
#define LED_OFF_DURATION_MS 5000

// ADC Handles and Calibration Data
static adc_oneshot_unit_handle_t adc1_handle;
static adc_cali_handle_t adc1_cali_handle = NULL; // Calibration handle
static bool adc_calibrated = false;

// Function to initialize ADC calibration using modern API (Curve Fitting only)
static bool adc_calibration_init_ng(adc_unit_t unit, adc_channel_t chan, adc_atten_t atten, adc_cali_handle_t *out_handle)
{
    adc_cali_handle_t handle = NULL;
    esp_err_t ret = ESP_FAIL;
    bool calibrated = false;

    // Attempt Curve Fitting calibration (recommended for C3)
    ESP_LOGI(TAG, "Attempting ADC calibration using Curve Fitting scheme...");
    adc_cali_curve_fitting_config_t cali_config = {
        .unit_id = unit,
        .chan = chan, // Pass the channel
        .atten = atten,
        .bitwidth = ADC_BITWIDTH_DEFAULT,
    };
    ret = adc_cali_create_scheme_curve_fitting(&cali_config, &handle);
    if (ret == ESP_OK) {
        calibrated = true;
        ESP_LOGI(TAG, "ADC Curve Fitting calibration successful.");
    } else if (ret == ESP_ERR_NOT_SUPPORTED || ret == ESP_ERR_INVALID_STATE) {
        ESP_LOGW(TAG, "Curve Fitting calibration not supported or eFuse not available/valid (%s)", esp_err_to_name(ret));
    } else {
        ESP_LOGE(TAG, "ADC Curve Fitting calibration failed with error: %s", esp_err_to_name(ret));
    }

    *out_handle = handle; // Assign handle even if NULL (indicates failure)
    return calibrated;
}

// Function to initialize ADC One-Shot mode and Modern Calibration
static void adc_init_ng(void)
{
    //-------------ADC1 Init---------------//
    adc_oneshot_unit_init_cfg_t init_config1 = {
        .unit_id = ADC_UNIT_1,
        .ulp_mode = ADC_ULP_MODE_DISABLE, // ULP mode not used
    };
    ESP_ERROR_CHECK(adc_oneshot_new_unit(&init_config1, &adc1_handle));

    //-------------ADC1 Config Channel---------------//
    adc_oneshot_chan_cfg_t config = {
        .bitwidth = ADC_BITWIDTH_DEFAULT, // Use default bitwidth (usually 12-bit for C3)
        .atten = ADC_ATTEN,
    };
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc1_handle, ADC1_CHAN4, &config));

    //-------------ADC1 Modern Calibration Init---------------//
    // Pass the specific channel to the calibration init function
    adc_calibrated = adc_calibration_init_ng(ADC_UNIT_1, ADC1_CHAN4, ADC_ATTEN, &adc1_cali_handle);

    if (adc_calibrated) {
         ESP_LOGI(TAG, "ADC1 calibration initialization successful.");
    } else {
         ESP_LOGW(TAG, "ADC1 calibration initialization failed or not performed.");
    }
}


static void configure_led(void)
{
    ESP_LOGI(TAG, "Configuring GPIO%d as output", BLINK_GPIO);
    gpio_reset_pin(BLINK_GPIO);
    /* Set the GPIO as a push/pull output */
    gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);
}

void app_main(void)
{
    /* Configure the LED peripheral */
    configure_led();

    /* Configure the ADC peripheral using modern functions */
    adc_init_ng();

    int adc_raw;
    int voltage_mv; // Voltage in millivolts
    bool led_state = false; // Start with LED OFF
    int64_t last_led_change_time_us = esp_timer_get_time(); // Use microsecond timer

    gpio_set_level(BLINK_GPIO, 0); // Ensure LED is initially OFF
    ESP_LOGD(TAG, "Initial LED state: OFF");

    while (1) {
        // --- ADC Reading (One-Shot) ---
        esp_err_t read_ret = adc_oneshot_read(adc1_handle, ADC1_CHAN4, &adc_raw);
        if (read_ret == ESP_OK) {
            // ESP_LOGD(TAG, "Raw ADC Data: %d", adc_raw); // Use Debug for less verbose raw logs
            if (adc_calibrated && adc1_cali_handle != NULL) { // Check if handle is valid
                esp_err_t cali_ret = adc_cali_raw_to_voltage(adc1_cali_handle, adc_raw, &voltage_mv);
                if (cali_ret == ESP_OK) {
                    // Print voltage in Volts
                    ESP_LOGI(TAG, "GPIO%d Voltage: %.3f V", 4, (float)voltage_mv / 1000.0);
                } else {
                    ESP_LOGE(TAG, "Calibration conversion failed: %s", esp_err_to_name(cali_ret));
                    ESP_LOGI(TAG, "Raw ADC Data (calibration failed): %d", adc_raw);
                }
            } else {
                ESP_LOGW(TAG, "ADC Not Calibrated. Raw value: %d", adc_raw);
            }
        } else {
            ESP_LOGE(TAG, "ADC read failed: %s", esp_err_to_name(read_ret));
        }

        // --- LED Blinking State Machine ---
        int64_t current_time_us = esp_timer_get_time();
        int64_t time_since_last_change_ms = (current_time_us - last_led_change_time_us) / 1000;

        if (led_state == true) { // If LED is currently ON
            if (time_since_last_change_ms >= LED_ON_DURATION_MS) {
                gpio_set_level(BLINK_GPIO, 0); // Turn OFF
                led_state = false;
                last_led_change_time_us = current_time_us;
                ESP_LOGD(TAG, "Turning LED OFF");
            }
        } else { // If LED is currently OFF
            if (time_since_last_change_ms >= LED_OFF_DURATION_MS) {
                gpio_set_level(BLINK_GPIO, 1); // Turn ON
                led_state = true;
                last_led_change_time_us = current_time_us;
                ESP_LOGD(TAG, "Turning LED ON");
            }
        }

        // --- Loop Delay ---
        vTaskDelay(pdMS_TO_TICKS(500)); // Loop approximately every 500ms
    }

    // Note: For a real application, cleanup should be added, e.g.:
    // ESP_ERROR_CHECK(adc_oneshot_del_unit(adc1_handle));
    // if (adc_calibrated) {
    //     ESP_ERROR_CHECK(adc_cali_delete_scheme_curve_fitting(adc1_cali_handle));
    // }
}