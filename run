#!/bin/bash
# ESP32 Device Management Script (Main Entry Point)
# Simplifies interactions with ESP32 device using argparse-bash

# Get the script directory (project root)
SCRIPT_DIR_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Source common functions and variables
# shellcheck source=./scripts/common.sh
source "$SCRIPT_DIR_ROOT/scripts/common.sh" || { echo "Error: Unable to source scripts/common.sh" >&2; exit 1; }

# Source argparse-bash
source "$SCRIPT_DIR_ROOT/scripts/argparse.bash" || { echo "Error: Unable to source scripts/argparse.bash" >&2; exit 1; }

# --- Define Arguments and Commands (Python argparse syntax) ---

# Note: This function now *outputs* Python code for argparse.bash to use.
parser_definition() {
    # Main parser setup
    echo "parser.description = 'ESP32 Device Management Script. Interacts with the device via HTTP API or ampy.'"
    echo "parser.add_argument('--ap', action='store_true', help='Use AP IP address ($AP_IP) instead of configured IP')"
    echo "parser.add_argument('--ampy', action='store_true', help='Use ampy (Port: $AMPY_PORT) for serial communication instead of HTTP API')"

    # Subparsers setup
    echo "subparsers = parser.add_subparsers(dest='command', help='Available commands', required=True)" # Use dest='command'

    # --- Define Commands ---
    echo "parser_reset = subparsers.add_parser('reset', help='Reset the ESP32 device')"
    echo "parser_log = subparsers.add_parser('log', help='View device logs')"
    echo "parser_log_clear = subparsers.add_parser('log-clear', help='Clear the log file on the device')"
    echo "parser_log_add_test = subparsers.add_parser('log-add-test', help='Add 1000 test log entries')"
    echo "parser_ls = subparsers.add_parser('ls', help='List all files on the device (alias for la)')"
    echo "parser_la = subparsers.add_parser('la', help='List all files on the device')"
    echo "parser_fs_list = subparsers.add_parser('fs-list', help='Get JSON file listing for visual tools')"
    echo "parser_free = subparsers.add_parser('free', help='Show free memory on the device')"
    echo "parser_ping = subparsers.add_parser('ping', help='Check if the device is responding')"
    echo "parser_status = subparsers.add_parser('status', help='Check device status and update IP file if needed')"

    echo "parser_rm = subparsers.add_parser('rm', help='Remove a file from the device')"
    echo "parser_rm.add_argument('path', help='Path of the file to remove on the device')" # 'path' argument

    echo "parser_rm_visual = subparsers.add_parser('rm-visual', help='Interactive visual file removal (uses scripts/rm-visual)')"

    echo "parser_download = subparsers.add_parser('download', help='Download a file from the device')"
    echo "parser_download.add_argument('path', help='Path of the file to download from the device')" # 'path' argument

    echo "parser_view = subparsers.add_parser('view', help='View the contents of a file on the device')"
    echo "parser_view.add_argument('path', help='Path of the file to view on the device')" # 'path' argument

    echo "parser_upload = subparsers.add_parser('upload', help='Upload files (delegated to scripts/upload.sh)')"
    echo "parser_upload.add_argument('upload_args', nargs=argparse.REMAINDER, help='Arguments for upload.sh (e.g., [--py|--no-compile] <file(s)> [target])')" # Capture remaining args

    echo "parser_sync = subparsers.add_parser('sync', help='Sync modified files (delegated to scripts/sync.sh)')"
    echo "parser_sync.add_argument('sync_args', nargs=argparse.REMAINDER, help='Arguments for sync.sh (e.g., [--py|--no-compile] [--dry-run] [--force])')" # Capture remaining args

    # Help command is usually handled implicitly by argparse, but defining explicitly can sometimes help
    # echo "parser_help = subparsers.add_parser('help', help='Show help message')"
}

# --- Parse Arguments ---
# Pass the parser definition (python code) via stdin to the argparse function
# The result is stored in global variables like $COMMAND, $AP, $AMPY, $PATH, $UPLOAD_ARGS etc. (uppercase)
# Note: argparse.bash converts python args.my_arg to bash MY_ARG
argparse "$@" <<< "$(parser_definition)" || exit 1

# --- Determine Target IP ---
# Use the flag parsed by argparse (now uppercase: AP, AMPY)
if [ "$AP" = "yes" ]; then # argparse.bash sets boolean flags to "yes" or ""
    ESP_IP="$AP_IP" # AP_IP is sourced from common.sh
    echo "Using AP IP address: $ESP_IP"
elif saved_ip=$(read_ip_from_json); then # read_ip_from_json is sourced
    ESP_IP="$saved_ip"
    # Optionally echo the used IP: echo "Using saved IP address: $ESP_IP"
else
    echo "Warning: IP file not found or invalid at $IP_JSON_FILE" # IP_JSON_FILE is sourced
    echo "Using AP IP address instead: $AP_IP"
    ESP_IP="$AP_IP"
fi
# Export ESP_IP so make_request can see it
export ESP_IP

# --- Command Dispatch ---

# Main command logic using case statement with $COMMAND from argparse
case "$COMMAND" in
  reset)
        check_sync_needed # Sourced from common.sh
        if [ "$AMPY" = "yes" ]; then
          echo "Resetting ESP32 using ampy (Port: $AMPY_PORT)..."
          ampy -p "$AMPY_PORT" reset
        else
          echo "Resetting ESP32 at $ESP_IP..."
          make_request "http://$ESP_IP/reset" "POST" # make_request sourced
          echo "Reset command sent."
        fi
        ;;

  log)
        check_sync_needed
        echo "Fetching logs from ESP32 at $ESP_IP..."
        make_request "http://$ESP_IP/api/log/chunk"
        ;;

  log-clear)
        check_sync_needed
        echo "Clearing logs on ESP32 at $ESP_IP..."
        make_request "http://$ESP_IP/log/clear" "POST"
        ;;

  log-add-test)
       check_sync_needed
       echo "Adding 1000 test log entries on ESP32 at $ESP_IP..."
       make_request "http://$ESP_IP/log/add-test-entries" "POST"
       ;;

  la|ls)
        check_sync_needed
        if [ "$AMPY" = "yes" ]; then
          echo "Listing all files on ESP32 using ampy (Port: $AMPY_PORT)..."
          ampy -p "$AMPY_PORT" ls
        else
          echo "Listing all files on ESP32 at $ESP_IP..."
          make_request "http://$ESP_IP/la"
        fi
        ;;

  fs-list)
        check_sync_needed
        # echo "Getting JSON file listing from ESP32 at $ESP_IP..." # Removed for cleaner JSON output
        make_request "http://$ESP_IP/fs-list"
        ;;

  free)
        check_sync_needed
        echo "Checking free memory on ESP32 at $ESP_IP..."
        make_request "http://$ESP_IP/free"
        ;;

  ping)
        check_sync_needed
        echo "Pinging ESP32 at $ESP_IP..."
        make_request "http://$ESP_IP/ping"
        ;;

  status)
        check_sync_needed
        echo "Checking status of ESP32 at $ESP_IP..."
        response=$(make_request "http://$ESP_IP/status")
        status_code=$?
        echo "$response"

        # Update IP file logic (uses sourced functions/variables)
        if [ $status_code -eq 0 ] && printf '%s' "$response" | jq -e '.wifi_ip' >/dev/null 2>&1; then
            wifi_ip=$(echo "$response" | jq -r '.wifi_ip')
            need_update=false
            if [ -f "$IP_JSON_FILE" ]; then
                check_jq # Sourced
                current_ip=$(jq -r '.ip' "$IP_JSON_FILE")
                if [ "$wifi_ip" != "$current_ip" ]; then
                    echo "IP has changed from $current_ip to $wifi_ip. Updating IP file..."
                    need_update=true
                else
                    echo "IP unchanged: $wifi_ip"
                fi
            else
                echo "IP file not found at $IP_JSON_FILE. Creating with IP: $wifi_ip"
                need_update=true
            fi
            if [ "$need_update" = true ]; then
                write_ip_to_json "$wifi_ip" # Sourced
                echo "IP file updated."
            fi
        elif [ $status_code -eq 0 ]; then
             echo "WiFi not connected or status information incomplete."
        # else make_request already printed an error
        fi
        ;;

  rm)
        check_sync_needed
        # FILE_PATH is now $PATH from argparse (uppercase)
        FILE_PATH="$PATH"

        if [ "$AMPY" = "yes" ]; then
            echo "Removing file $FILE_PATH from ESP32 using ampy (Port: $AMPY_PORT)..."
            ampy -p "$AMPY_PORT" rm "$FILE_PATH"
        else
            echo "Removing file $FILE_PATH from ESP32 at $ESP_IP..."
            make_request "http://$ESP_IP/rm/$FILE_PATH" "DELETE"
        fi
        ;;

  rm-visual)
        check_sync_needed
        # Run the visual rm script from the scripts directory
        echo "Launching visual file removal..."
        "$SCRIPT_DIR_ROOT/scripts/rm-visual"
        exit $? # Exit with the status of rm-visual
        ;;

  download)
        check_sync_needed
        # FILE_PATH is now $PATH from argparse (uppercase)
        FILE_PATH="$PATH"
        DOWNLOAD_TARGET="$(basename "$FILE_PATH")"
        echo "Downloading $FILE_PATH from ESP32 at $ESP_IP to $DOWNLOAD_TARGET..."
        make_request "http://$ESP_IP/fs/get/$FILE_PATH" "GET" "$DOWNLOAD_TARGET"
        if [ $? -eq 0 ]; then
            echo "Downloaded to $DOWNLOAD_TARGET"
        else
            echo "Download failed." >&2
            # Optionally remove partially downloaded file
            # rm -f "$DOWNLOAD_TARGET"
            exit 1
        fi
        ;;

  view)
        check_sync_needed
        # FILE_PATH is now $PATH from argparse (uppercase)
        FILE_PATH="$PATH"
        echo "Viewing file $FILE_PATH from ESP32 at $ESP_IP..."
        make_request "http://$ESP_IP/view/$FILE_PATH"
        ;;

  upload)
        check_sync_needed
        echo "Delegating upload to scripts/upload.sh..."
        # Prepare args for upload.sh
        upload_script_args=("--ip" "$ESP_IP") # Pass the determined IP
        if [ "$AMPY" = "yes" ]; then
            upload_script_args+=("--ampy")
        fi
        # Pass the remaining arguments captured by argparse
        # Note: UPLOAD_ARGS is the array of remaining args (uppercase)
        upload_script_args+=("${UPLOAD_ARGS[@]}")

        "$SCRIPT_DIR_ROOT/scripts/upload.sh" "${upload_script_args[@]}"
        exit $? # Exit with the status of upload.sh
        ;;

  sync)
        # No need for check_sync_needed here, sync.sh does it
        echo "Delegating sync to scripts/sync.sh..."
        # Prepare args for sync.sh
        sync_script_args=("--ip" "$ESP_IP") # Pass the determined IP
        if [ "$AMPY" = "yes" ]; then
            sync_script_args+=("--ampy")
        fi
         # Pass the remaining arguments captured by argparse
         # Note: SYNC_ARGS is the array of remaining args (uppercase)
        sync_script_args+=("${SYNC_ARGS[@]}")

        "$SCRIPT_DIR_ROOT/scripts/sync.sh" "${sync_script_args[@]}"
        exit $? # Exit with the status of sync.sh
        ;;

  # help command is handled by argparse itself when called like ./run --help or ./run rm --help

  *)
    # This case should ideally not be reached if argparse is working correctly,
    # as it handles unknown commands. But keep it as a fallback.
    echo "Error: Unknown command '$COMMAND'" >&2
    # Consider calling the parser's help function if possible, or exit
    exit 1
    ;;
esac

exit 0 # Default exit code for successful command execution