<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Logs</title>
    <style>
        body {
            font-family: monospace;
            background-color: #f4f4f4;
            margin: 0;
            padding: 10px;
            color: #333;
        }

        #log-container {
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 15px;
            white-space: pre-wrap;
            /* Allows wrapping long lines */
            word-wrap: break-word;
            /* Breaks long words/lines */
            min-height: 90vh;
            /* Ensure it takes up significant height */
            overflow-y: auto;
            /* Should not be needed if body scrolls */
            font-size: 0.9em;
            line-height: 1.4;
        }

        .loading-indicator {
            text-align: center;
            padding: 10px;
            font-style: italic;
            color: #777;
        }

        /* Style for newly added logs */
        .new-log {
            animation: highlight 2s ease-out;
        }

        @keyframes highlight {
            from {
                background-color: yellow;
            }

            to {
                background-color: transparent;
            }
        }
    </style>
</head>
<body>

    <h1>Device Logs (Live)</h1>
    <div id="loading-older" class="loading-indicator" style="display: none;">Loading older logs...</div>
    <pre id="log-container"></pre>
    <div id="loading-newer" class="loading-indicator" style="display: none;">Loading new logs...</div>

    <script>
        const logContainer = document.getElementById('log-container');
        const loadingOlderIndicator = document.getElementById('loading-older');
        const loadingNewerIndicator = document.getElementById('loading-newer');

        const INITIAL_LOAD_LINES = 150; // Approx 1.5 screens initially
        const SCROLL_LOAD_LINES = 100;  // Lines to load on scroll
        const LIVE_UPDATE_INTERVAL = 10000; // Check for new logs every 10 seconds (ms) - Increased interval

        let currentOffset = 0;
        let isLoadingOlder = false;
        let isLoadingNewer = false;
        let lastNewestTimestampMs = 0;
        let noMoreOlderLogs = false; // Flag to stop trying to load older logs

        const monthMap = {
            "Jan": 0, "Feb": 1, "Mar": 2, "Apr": 3, "May": 4, "Jun": 5,
            "Jul": 6, "Aug": 7, "Sep": 8, "Oct": 9, "Nov": 10, "Dec": 11
        };

        function parseTimestampFromLogLine(line) {
            // Format: DD-Mon-YYYY HH:MM:SS.ms
            try {
                const tsStr = line.substring(0, 24);
                if (tsStr.length !== 24 || tsStr[2] !== '-' || tsStr[6] !== '-' || tsStr[11] !== ' ' || tsStr[14] !== ':' || tsStr[17] !== ':' || tsStr[20] !== '.') {
                    return null; // Basic format check
                }

                const day = parseInt(tsStr.substring(0, 2), 10);
                const monthAbbr = tsStr.substring(3, 6);
                const year = parseInt(tsStr.substring(7, 11), 10);
                const hour = parseInt(tsStr.substring(12, 14), 10);
                const minute = parseInt(tsStr.substring(15, 17), 10);
                const second = parseInt(tsStr.substring(18, 20), 10);
                const ms = parseInt(tsStr.substring(21, 24), 10);

                const month = monthMap[monthAbbr];
                if (month === undefined) return null;

                // Note: JS Date month is 0-indexed
                const date = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
                return date.getTime(); // Milliseconds since epoch (UTC)
            } catch (e) {
                console.error("Error parsing timestamp from line:", line, e);
                return null;
            }
        }

        function displayLogs(logText, prepend = false) {
            if (!logText) return 0; // No logs to display

            const lines = logText.split('\n').filter(line => line.trim() !== ''); // Filter out empty lines
            if (lines.length === 0) return 0;

            const fragment = document.createDocumentFragment();
            let newestTsInBatch = 0; // Track newest timestamp only when appending

            // Optimization: Only parse timestamp for the last line when appending
            if (!prepend && lines.length > 0) {
                const lastLine = lines[lines.length - 1];
                newestTsInBatch = parseTimestampFromLogLine(lastLine) || 0; // Use 0 if parsing fails
            }

            lines.forEach(line => {
                const lineElement = document.createTextNode(line + '\n');

                // Add highlight class if appending new logs
                if (!prepend) {
                    const span = document.createElement('span');
                    span.className = 'new-log';
                    span.appendChild(lineElement);
                    fragment.appendChild(span);
                } else {
                    fragment.appendChild(lineElement); // Prepending older logs
                }
            });

            if (prepend) {
                logContainer.insertBefore(fragment, logContainer.firstChild);
            } else {
                logContainer.appendChild(fragment);
                // Update the global newest timestamp only when appending
                if (newestTsInBatch > lastNewestTimestampMs) {
                    lastNewestTimestampMs = newestTsInBatch;
                }
            }
            return lines.length; // Return number of lines added
        }

        async function fetchLogs({ limit, offset, newer_than_ms } = {}) {
            let url = '/api/log/chunk?';
            const params = [];
            if (limit !== undefined) params.push(`limit=${limit}`);
            if (offset !== undefined) params.push(`offset=${offset}`);
            if (newer_than_ms !== undefined) params.push(`newer_than_timestamp_ms=${newer_than_ms}`);

            url += params.join('&');

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    console.error(`Error fetching logs: ${response.status} ${response.statusText}`);
                    const errorText = await response.text();
                    console.error("Server response:", errorText);
                    return null; // Indicate error
                }
                return await response.text();
            } catch (error) {
                console.error('Network error fetching logs:', error);
                return null; // Indicate error
            }
        }

        async function loadOlderLogs() {
            if (isLoadingOlder || noMoreOlderLogs) return;

            isLoadingOlder = true;
            loadingOlderIndicator.style.display = 'block';

            const currentScroll = window.scrollY; // Store scroll position

            const logText = await fetchLogs({ limit: SCROLL_LOAD_LINES, offset: currentOffset });

            if (logText !== null) {
                const linesAdded = displayLogs(logText, true); // Prepend logs
                if (linesAdded > 0) {
                    currentOffset += linesAdded;
                    // Try to restore scroll position relative to the content added
                    const newHeight = logContainer.scrollHeight;
                    const oldHeight = newHeight - (logContainer.firstChild.offsetHeight || 0); // Approximate height added
                    window.scrollTo(0, currentScroll + (newHeight - oldHeight)); // Adjust scroll
                } else {
                    // No more older logs were returned
                    noMoreOlderLogs = true;
                    loadingOlderIndicator.textContent = 'No more older logs.';
                    // Hide indicator after a delay
                    setTimeout(() => { loadingOlderIndicator.style.display = 'none'; }, 2000);
                }
            } else {
                // Handle fetch error - maybe show a message
                loadingOlderIndicator.textContent = 'Error loading older logs.';
                setTimeout(() => { loadingOlderIndicator.style.display = 'none'; }, 3000);
            }


            isLoadingOlder = false;
            if (!noMoreOlderLogs) { // Hide only if we might load more later
                loadingOlderIndicator.style.display = 'none';
            }
        }

        async function loadNewerLogs() {
            if (isLoadingNewer) return;
            isLoadingNewer = true;
            // Optionally show a subtle loading indicator for newer logs if desired
            // loadingNewerIndicator.style.display = 'block';

            const logText = await fetchLogs({ newer_than_ms: lastNewestTimestampMs });

            if (logText !== null) {
                const wasScrolledToBottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 20; // Check if user is near the bottom

                const linesAdded = displayLogs(logText, false); // Append logs

                if (linesAdded > 0 && wasScrolledToBottom) {
                    // Auto-scroll to bottom if user was already there
                    window.scrollTo(0, document.body.scrollHeight);
                }
            } else {
                // Handle fetch error
                // loadingNewerIndicator.textContent = 'Error loading new logs.';
                // setTimeout(() => { loadingNewerIndicator.style.display = 'none'; }, 3000);
            }

            isLoadingNewer = false;
            // loadingNewerIndicator.style.display = 'none';
        }

        // --- Event Listeners and Initial Load ---

        window.addEventListener('scroll', () => {
            // Load older logs when scrolling near the top
            if (window.scrollY < 100) { // Adjust threshold as needed
                loadOlderLogs();
            }
        });

        // Initial load
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Loading initial logs...");
            const initialLogText = await fetchLogs({ limit: INITIAL_LOAD_LINES });
            console.log('initialLogText', initialLogText)

            if (initialLogText !== null) {
                const linesAdded = displayLogs(initialLogText, false); // Append initial logs
                currentOffset = linesAdded; // Set initial offset
                console.log(`Initial load complete. Offset: ${currentOffset}, Newest Timestamp: ${lastNewestTimestampMs}`);
                if (linesAdded < INITIAL_LOAD_LINES) {
                    noMoreOlderLogs = true; // Assume no more older logs if initial load is less than requested
                    console.log("Initial load was less than requested limit, assuming no more older logs.");
                }
            } else {
                logContainer.textContent = "Error loading initial logs.";
            }

            // Start live update timer
            setInterval(loadNewerLogs, LIVE_UPDATE_INTERVAL);
        });

    </script>

</body>
</html>