<![CDATA[<!DOCTYPE html>
<html>
<head>
    <title>ESP32 Log Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: monospace;
            margin: 0;
            padding: 10px;
            background: #f0f0f0;
        }
        #log-container {
            background: #000;
            color: #0f0; /* Classic green on black */
            padding: 10px;
            height: calc(100vh - 100px); /* Adjust height as needed */
            overflow-y: scroll;
            border-radius: 4px;
            white-space: pre-wrap; /* Wrap long lines */
            word-wrap: break-word;
            font-size: 0.9em; /* Slightly smaller font */
        }
        .controls {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            padding: 8px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .status {
            color: #666;
            font-size: 0.9em;
        }
        .loading-indicator {
            display: none; /* Hidden by default */
            margin-left: 10px;
            font-style: italic;
        }
        .loading-indicator.active {
            display: inline; /* Show when loading */
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="refresh-btn">Refresh</button>
        <button id="clear-btn">Clear View</button>
        <label>
            <input type="checkbox" id="autoscroll-chk" checked> Autoscroll
        </label>
        <span id="status" class="status">Idle</span>
        <span id="loading" class="loading-indicator">Loading...</span>
    </div>

    <pre id="log-container"></pre>

    <script>
        const logContainer = document.getElementById('log-container');
        const refreshBtn = document.getElementById('refresh-btn');
        const clearBtn = document.getElementById('clear-btn');
        const status = document.getElementById('status');
        const loadingIndicator = document.getElementById('loading');
        const autoscrollChk = document.getElementById('autoscroll-chk');

        // State variables
        let isLoadingOlder = false;
        let isLoadingNewer = false;
        let currentOffset = 0;
        let lastNewestTimestamp = null;
        let autoRefreshInterval = null;
        const REFRESH_INTERVAL_MS = 3000; // Check for new logs every 3 seconds
        const LINES_PER_CHUNK = 30; // Number of lines to fetch per request

        // --- Utility Functions ---

        function setLoading(older, newer) {
            isLoadingOlder = older;
            isLoadingNewer = newer;
            loadingIndicator.classList.toggle('active', older || newer);
            status.textContent = (older || newer) ? 'Loading...' : 'Idle';
        }

        // Simple timestamp parser (adjust if format changes)
        function parseTimestamp(line) {
            if (!line || line.length < 24) return null;
            try {
                // Format: DD-Mon-YYYY HH:MM:SS.ms
                const months = { 'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5, 'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11 };
                const monthStr = line.substring(3, 6);
                if (months[monthStr] === undefined) return null;

                const year = parseInt(line.substring(7, 11));
                const day = parseInt(line.substring(0, 2));
                const hour = parseInt(line.substring(12, 14));
                const minute = parseInt(line.substring(15, 17));
                const second = parseInt(line.substring(18, 20));
                const ms = parseInt(line.substring(21, 24));

                // Use UTC to avoid timezone issues in parsing
                const date = new Date(Date.UTC(year, months[monthStr], day, hour, minute, second, ms));
                return date.getTime(); // Milliseconds since epoch
            } catch (e) {
                console.error("Timestamp parse error:", e, "on line:", line);
                return null;
            }
        }

        // Find the timestamp of the newest log line currently displayed
        function getNewestDisplayedTimestamp() {
            const firstLine = logContainer.textContent.split('\n', 1)[0];
            return parseTimestamp(firstLine);
        }

        // --- Core Logic ---

        async function fetchLogs(params) {
            const url = `/api/log/chunk?${params}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}: ${await response.text()}`);
                }
                const text = await response.text();
                return text.split('\n').filter(line => line.trim()); // Return array of non-empty lines
            } catch (error) {
                console.error(`Error fetching logs (${url}):`, error);
                status.textContent = `Error: ${error.message}`;
                throw error; // Re-throw to handle in calling function
            }
        }

        async function loadInitialLogs() {
            if (isLoadingOlder || isLoadingNewer) return;
            setLoading(true, false);
            logContainer.textContent = ''; // Clear existing content
            currentOffset = 0;
            lastNewestTimestamp = null;

            try {
                const lines = await fetchLogs(`limit=${LINES_PER_CHUNK}`);
                if (lines.length > 0) {
                    logContainer.textContent = lines.join('\n') + '\n';
                    currentOffset = lines.length;
                    lastNewestTimestamp = parseTimestamp(lines[0]); // Newest is first
                    logContainer.scrollTop = logContainer.scrollHeight; // Scroll to bottom initially
                } else {
                    status.textContent = 'Log file is empty or unreadable.';
                }
            } catch (error) {
                // Error already logged by fetchLogs
            } finally {
                setLoading(false, false);
                startAutoRefresh(); // Start checking for new logs
            }
        }

        async function loadOlderLogs() {
            if (isLoadingOlder || isLoadingNewer) return;
            setLoading(true, false);

            // Remember scroll position relative to the bottom before adding content
            const scrollHeightBefore = logContainer.scrollHeight;
            const scrollTopBefore = logContainer.scrollTop;

            try {
                const lines = await fetchLogs(`offset=${currentOffset}&limit=${LINES_PER_CHUNK}`);
                if (lines.length > 0) {
                    logContainer.textContent = lines.join('\n') + '\n' + logContainer.textContent;
                    currentOffset += lines.length;

                    // Restore scroll position relative to the previous top
                    const scrollHeightAfter = logContainer.scrollHeight;
                    logContainer.scrollTop = scrollTopBefore + (scrollHeightAfter - scrollHeightBefore);
                    status.textContent = `Loaded ${lines.length} older lines.`;
                } else {
                    status.textContent = 'No more older logs found.';
                    // Optionally disable further scroll checks if no more logs
                }
            } catch (error) {
                // Error already logged
            } finally {
                setLoading(false, false);
            }
        }

        async function checkForNewLogs() {
            if (isLoadingOlder || isLoadingNewer || !lastNewestTimestamp) return;
            setLoading(false, true); // Indicate loading newer logs

            try {
                const lines = await fetchLogs(`newer_than_timestamp_ms=${lastNewestTimestamp}`);
                if (lines.length > 0) {
                    const shouldScroll = autoscrollChk.checked && (logContainer.scrollHeight - logContainer.scrollTop - logContainer.clientHeight < 5); // Check if near bottom

                    logContainer.textContent = lines.join('\n') + '\n' + logContainer.textContent;
                    lastNewestTimestamp = parseTimestamp(lines[0]); // Update newest timestamp

                    if (shouldScroll) {
                        logContainer.scrollTop = 0; // Scroll to top (where new logs are added)
                    }
                    status.textContent = `Added ${lines.length} new lines.`;
                } else {
                    // status.textContent = 'No new logs.'; // Can be noisy, keep Idle
                    status.textContent = 'Idle';
                }
            } catch (error) {
                // Error logged, stop auto-refresh on error
                stopAutoRefresh();
            } finally {
                setLoading(false, false);
            }
        }

        // --- Event Handlers & Setup ---

        function handleScroll() {
            // Load older logs when scrolled near the top
            if (logContainer.scrollTop < 50 && !isLoadingOlder) {
                loadOlderLogs();
            }
        }

        function startAutoRefresh() {
            stopAutoRefresh(); // Clear existing interval if any
            if (REFRESH_INTERVAL_MS > 0) {
                autoRefreshInterval = setInterval(checkForNewLogs, REFRESH_INTERVAL_MS);
            }
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        refreshBtn.addEventListener('click', loadInitialLogs);
        clearBtn.addEventListener('click', () => {
            logContainer.textContent = '';
            currentOffset = 0;
            lastNewestTimestamp = null;
            status.textContent = 'View cleared.';
            stopAutoRefresh(); // Stop refresh when clearing manually
        });
        logContainer.addEventListener('scroll', handleScroll);

        // Initial load on page ready
        document.addEventListener('DOMContentLoaded', loadInitialLogs);

    </script>
</body>
</html>]]>