<![CDATA[<!DOCTYPE html>
<html>
<head>
    <title>ESP32 Log Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: monospace;
            margin: 0;
            padding: 10px;
            background: #f0f0f0;
        }
        #log-container {
            background: #000;
            color: #0f0; /* Classic green on black */
            padding: 10px;
            height: calc(100vh - 100px); /* Adjust height as needed */
            overflow-y: scroll;
            border-radius: 4px;
            white-space: pre-wrap; /* Wrap long lines */
            word-wrap: break-word;
            font-size: 0.9em; /* Slightly smaller font */
        }
        .controls {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            padding: 8px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .status {
            color: #666;
            font-size: 0.9em;
        }
        .loading-indicator {
            display: none; /* Hidden by default */
            margin-left: 10px;
            font-style: italic;
        }
        .loading-indicator.active {
            display: inline; /* Show when loading */
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="refresh-btn">Refresh</button>
        <button id="clear-btn">Clear View</button>
        <label>
            <input type="checkbox" id="autoscroll-chk" checked> Autoscroll
        </label>
        <span id="status" class="status">Idle</span>
        <span id="loading" class="loading-indicator">Loading...</span>
    </div>

    <pre id="log-container"></pre>

    <script>
        const logContainer = document.getElementById('log-container');
        const refreshBtn = document.getElementById('refresh-btn');
        const clearBtn = document.getElementById('clear-btn');
        const status = document.getElementById('status');
        const loadingIndicator = document.getElementById('loading');
        const autoscrollChk = document.getElementById('autoscroll-chk');

        // State variables
        let isLoadingOlder = false;
        let isLoadingNewer = false;
        let currentOffset = 0;
        let lastNewestTimestamp = null;
        let autoRefreshInterval = null;
        const REFRESH_INTERVAL_MS = 3000; // Check for new logs every 3 seconds
        const LINES_PER_CHUNK = 30; // Number of lines to fetch per request

        // --- Utility Functions ---

        function setLoading(older, newer) {
            console.log(`JS: setLoading called with older=${older}, newer=${newer}. Current state: isLoadingOlder=${isLoadingOlder}, isLoadingNewer=${isLoadingNewer}`); // DEBUG
            isLoadingOlder = older;
            isLoadingNewer = newer;
            console.log(`JS: setLoading updated state: isLoadingOlder=${isLoadingOlder}, isLoadingNewer=${isLoadingNewer}`); // DEBUG
            loadingIndicator.classList.toggle('active', older || newer);
            // Set status text only if actually loading, otherwise keep previous status
            if (older || newer) {
                status.textContent = 'Loading...';
            }
        }

        // Simple timestamp parser (adjust if format changes)
        function parseTimestamp(line) {
            if (!line || line.length < 24) return null;
            try {
                // Format: DD-Mon-YYYY HH:MM:SS.ms
                const months = { 'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5, 'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11 };
                const monthStr = line.substring(3, 6);
                if (months[monthStr] === undefined) return null;

                const year = parseInt(line.substring(7, 11));
                const day = parseInt(line.substring(0, 2));
                const hour = parseInt(line.substring(12, 14));
                const minute = parseInt(line.substring(15, 17));
                const second = parseInt(line.substring(18, 20));
                const ms = parseInt(line.substring(21, 24));

                // Use UTC to avoid timezone issues in parsing
                const date = new Date(Date.UTC(year, months[monthStr], day, hour, minute, second, ms));
                return date.getTime(); // Milliseconds since epoch
            } catch (e) {
                console.error("Timestamp parse error:", e, "on line:", line);
                return null;
            }
        }

        // Find the timestamp of the newest log line currently displayed
        function getNewestDisplayedTimestamp() {
            const firstLine = logContainer.textContent.split('\n', 1)[0];
            const ts = parseTimestamp(firstLine);
            // console.log("JS: getNewestDisplayedTimestamp found:", ts); // DEBUG
            return ts;
        }

        // --- Core Logic ---

        async function fetchLogs(params, timeoutMs = 10000) { // Add timeout parameter (default 10s)
            const url = `/api/log/chunk?${params}`;
            console.log(`JS: Fetching logs: ${url}`); // DEBUG
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
            let response; // Define response outside try block

            try {
                response = await fetch(url, { signal: controller.signal }); // Pass signal
                clearTimeout(timeoutId); // Clear timeout if fetch completes

                console.log(`JS: Fetch response status: ${response.status} for ${url}`); // DEBUG

                if (!response.ok) {
                    // Try to get error text, but handle potential issues reading it
                    let errorText = `HTTP error ${response.status}`;
                    try {
                        console.log("JS: Fetch error - trying to read body..."); // DEBUG
                        errorText = await response.text(); // Await reading error body
                        console.error(`JS: Fetch error body: ${errorText}`); // DEBUG
                    } catch (e) { console.error("JS: Error reading error response body", e); }
                    throw new Error(errorText);
                }

                console.log("JS: Fetch success - trying to read body with .text()..."); // DEBUG
                const text = await response.text(); // Explicitly await .text()
                console.log("JS: Fetch success - .text() completed."); // DEBUG

                const lines = text.split('\n').filter(line => line.trim());
                console.log(`JS: Received ${lines.length} lines from ${url}`); // DEBUG
                return lines;
            } catch (error) {
                clearTimeout(timeoutId); // Ensure timeout is cleared on error too
                if (error.name === 'AbortError') {
                    console.error(`JS: Fetch timed out (${url})`); // DEBUG
                    status.textContent = 'Error: Request timed out.'; // Update status on timeout
                } else {
                    // Log error context if possible
                    console.error(`JS: Error fetching/processing logs (${url}):`, error, response ? `Status: ${response.status}` : 'No response object'); // DEBUG
                    status.textContent = `Error: ${error.message}`; // Update status on other errors
                }
                throw error; // Re-throw to handle in calling function
            }
        }


        async function loadInitialLogs() {
            console.log("JS: loadInitialLogs started"); // DEBUG
            if (isLoadingOlder || isLoadingNewer) return;
            setLoading(true, false);
            logContainer.textContent = ''; // Clear existing content
            currentOffset = 0;
            lastNewestTimestamp = null;

            try {
                const lines = await fetchLogs(`limit=${LINES_PER_CHUNK}`);
                if (lines.length > 0) {
                    logContainer.textContent = lines.join('\n') + '\n';
                    currentOffset = lines.length;
                    lastNewestTimestamp = parseTimestamp(lines[0]); // Newest is first
                    console.log(`JS: Initial load complete. Offset: ${currentOffset}, Newest TS: ${lastNewestTimestamp}`); // DEBUG
                    logContainer.scrollTop = logContainer.scrollHeight; // Scroll to bottom initially
                    status.textContent = 'Idle'; // Set status after loading
                } else {
                    console.log("JS: Initial load returned no lines."); // DEBUG
                    status.textContent = 'Log file is empty or unreadable.';
                }
            } catch (error) {
                console.error("JS: Error during initial load:", error); // DEBUG
                // Error already logged and status set by fetchLogs
            } finally {
                setLoading(false, false); // Clear loading indicator
                startAutoRefresh(); // Start checking for new logs
            }
        }

        async function loadOlderLogs() {
            console.log("JS: loadOlderLogs started"); // DEBUG
            if (isLoadingOlder || isLoadingNewer) return;
            setLoading(true, false);

            // Remember scroll position relative to the bottom before adding content
            const scrollHeightBefore = logContainer.scrollHeight;
            const scrollTopBefore = logContainer.scrollTop;

            try {
                const lines = await fetchLogs(`offset=${currentOffset}&limit=${LINES_PER_CHUNK}`);
                if (lines.length > 0) {
                    logContainer.textContent = lines.join('\n') + '\n' + logContainer.textContent;
                    currentOffset += lines.length;
                    console.log(`JS: Loaded ${lines.length} older lines. New offset: ${currentOffset}`); // DEBUG

                    // Restore scroll position relative to the previous top
                    const scrollHeightAfter = logContainer.scrollHeight;
                    logContainer.scrollTop = scrollTopBefore + (scrollHeightAfter - scrollHeightBefore);
                    status.textContent = `Loaded ${lines.length} older lines.`;
                } else {
                    console.log("JS: No more older logs found."); // DEBUG
                    status.textContent = 'No more older logs found.';
                    // Optionally disable further scroll checks if no more logs
                }
            } catch (error) {
                console.error("JS: Error loading older logs:", error); // DEBUG
                // Error already logged and status set by fetchLogs
            } finally {
                setLoading(false, false); // Clear loading indicator
            }
        }

        async function checkForNewLogs() {
            console.log("JS: checkForNewLogs started"); // DEBUG
            // Prevent concurrent checks
            if (isLoadingOlder || isLoadingNewer) {
                console.log("JS: Skipping check for new logs: Already loading."); // DEBUG
                return;
            }
            // Don't check if we don't have a starting point
            if (!lastNewestTimestamp) {
                console.log("JS: Skipping check for new logs: lastNewestTimestamp is null."); // DEBUG
                // Ensure status is idle if we skip
                if (!isLoadingOlder) status.textContent = 'Idle';
                return;
            }

            console.log(`JS: Checking for logs newer than ${lastNewestTimestamp}`); // DEBUG
            setLoading(false, true); // Indicate loading newer logs

            try {
                console.log("JS: checkForNewLogs - Entering try block"); // DEBUG
                // Pass timeout to fetchLogs
                const lines = await fetchLogs(`newer_than_timestamp_ms=${lastNewestTimestamp}`, 8000); // 8 second timeout
                console.log("JS: checkForNewLogs - fetchLogs promise resolved, processing results..."); // DEBUG

                if (lines.length > 0) {
                    console.log("JS: checkForNewLogs - Found new lines, processing..."); // DEBUG
                    const shouldScroll = autoscrollChk.checked && (logContainer.scrollHeight - logContainer.scrollTop - logContainer.clientHeight < 10); // Check if near bottom

                    logContainer.textContent = lines.join('\n') + '\n' + logContainer.textContent;
                    const newTimestamp = parseTimestamp(lines[0]); // Get timestamp before updating status
                    if (newTimestamp) { // Only update if valid
                        console.log(`JS: Updating lastNewestTimestamp from ${lastNewestTimestamp} to ${newTimestamp}`); // DEBUG
                        lastNewestTimestamp = newTimestamp;
                    } else {
                        console.warn("JS: Could not parse timestamp from newest received line:", lines[0]); // DEBUG
                    }

                    if (shouldScroll) {
                        logContainer.scrollTop = 0; // Scroll to top (where new logs are added)
                    }
                    // Set status *after* potential UI updates
                    status.textContent = `Added ${lines.length} new lines.`;
                    console.log(`JS: Added ${lines.length} new lines.`); // DEBUG

                } else {
                    // Explicitly set status when no new lines are found
                    console.log("JS: No new lines found."); // DEBUG
                    status.textContent = 'Idle (no new logs)';
                }
                console.log("JS: checkForNewLogs - try block finished"); // DEBUG
            } catch (error) {
                // Error already logged by fetchLogs, stop auto-refresh
                console.error("JS: Stopping auto-refresh due to error in checkForNewLogs:", error); // DEBUG
                stopAutoRefresh();
                // Status is already set by fetchLogs on error
            } finally {
                // Ensure loading state is always cleared
                console.log("JS: checkForNewLogs - Entering finally block"); // DEBUG
                setLoading(false, false);
                console.log("JS: checkForNewLogs - Exiting finally block"); // DEBUG
            }
        }


        // --- Event Handlers & Setup ---

        function handleScroll() {
            // Load older logs when scrolled near the top
            if (logContainer.scrollTop < 50 && !isLoadingOlder) {
                loadOlderLogs();
            }
        }

        function startAutoRefresh() {
            stopAutoRefresh(); // Clear existing interval if any
            if (REFRESH_INTERVAL_MS > 0) {
                console.log(`JS: Starting auto-refresh every ${REFRESH_INTERVAL_MS}ms`); // DEBUG
                autoRefreshInterval = setInterval(checkForNewLogs, REFRESH_INTERVAL_MS);
            }
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                console.log("JS: Stopping auto-refresh."); // DEBUG
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        refreshBtn.addEventListener('click', loadInitialLogs);
        clearBtn.addEventListener('click', () => {
            logContainer.textContent = '';
            currentOffset = 0;
            lastNewestTimestamp = null;
            status.textContent = 'View cleared.';
            stopAutoRefresh(); // Stop refresh when clearing manually
        });
        logContainer.addEventListener('scroll', handleScroll);

        // Initial load on page ready
        document.addEventListener('DOMContentLoaded', loadInitialLogs);

    </script>
</body>
</html>]]>